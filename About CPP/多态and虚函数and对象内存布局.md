### 多态

> *C++多态性是通过虚函数实现，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。（这里我觉得要补充，重写的话可以有两种，直接重写成员函数和重写虚函数，只有重写了虚函数的才能算作是体现了C++多态性）而重载则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。但这并没有体现多态性。*

* **多态的应用场景**
1. 存在一个继承体系结构。如果不存在继承体系结构，那么所谓的多态就无从谈起
2. 在该继承体系结构中的所有类里面，均需要实现一个统一的函数接口，且该函数接口的行为在运行时才能确定这样的情形，就可以考虑使用多态，即“一个接口，多种方法”
3. 封装使得代码模块化，继承可以扩展已经存在的代码，目的都是为了代码重用。而多态的目的是为了接口重用。也就是说，不论究竟是那个类的对象，都能够通过同一个接口调用到适应各自对象的实现方法。
4. 把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，试图使用相同的代码来实现可变的算法，适应需求的不断变化。

### 虚函数

* **派生类对同名的基类函数的屏蔽**
1. 如果派生类的函数与基类的函数同名，但是参数不同， 不论有没有virtual关键，基类的函数将被隐藏（注意不要与重载混淆）
2. 如果派生类的函数与基类的函数同名，而且参数也相同，但是基类函数没有virtual关键字，基类的函数被隐藏（注意别与覆盖混淆）

* **虚析构函数**
虚析构函数保证了在析构时，避免只调用基类析构函数而不调用派生类析构函数的情况，保证资源正常释放，避免了内存泄露。只有当一个类被用来作为基类的时候，才会把析构函数写成虚函数。

* **纯虚函数**

> *在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决这个问题，方便使用类的多态性，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象*

1. **引入纯虚函数的原因**
* 为了方便使用多态特性，需要在基类中定义虚拟函数
* 基类本身生成对象是不合情理的
* 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口

2. **总结**
* 纯虚函数在基类中一定没有定义，而是用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例
* 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类可以覆盖该虚函数，由多态方式调用的时候动态绑定
* 析构函数应当是虚函数，将调用相应对象类型的析构函数，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。否则会造成对象析构不完全

### 对象内存布局

* **虚函数表**
1. 大多数编译器保证虚函数表的指针存在于对象实例中最前面的位置，大小为4个字节
2. 含有虚函数或其父类包含虚函数的类(而不是类实例)都有自己的虚表
3. 虚表存放的位置一般存放在模块的常量段中，从始至终都只有一份
4. 虚函数表的前面一般会设置一个指向type_info的指针，用以支持RTTI（Run Time Type Identification，运行时类型识别）。RTTI是为多态而生成的信息，包括对象继承关系，对象本身的描述等，只有具有虚函数的类才会生成

* **继承下的C++对象模型**

1. 单继承
对于一般的单继承（非虚拟继承），如果子类重写了父类的某些虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数（子类和父类拥有各自的一个虚函数表）；如果子类没有重写父类的虚函数，而是声明了自己的虚函数，则该虚函数的地址会扩充到虚函数表的最后。但是对于虚拟继承，如果子类重写父类虚函数，同样将覆盖虚表中对应的父类虚函数，而子类如果声明了自己新的虚函数，则编译器将为子类增加一个新的虚表指针vptr。

2. 多继承

**一般的多重继承（非菱形继承）**
* *子类的虚函数被放在声明的第一个基类的虚函数表中*
* *overwrite时，所有基类的print()函数都被子类的print()函数覆盖*
* *内存布局中，父类按照其声明顺序排列*

**菱形继承**

菱形继承也称为钻石型继承或重复继承，它指的是基类被某个派生类简单重复继承了多次。这样，派生类对象中拥有多份相同的基类实例，不仅增大了空间，还会引起程序歧义。

**虚继承**

虚继承解决了菱形继承中最派生类拥有多个间接父类实例的情况。虚继承的派生类的内存布局与普通继承很多不同：
* *虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一张虚函数表。非虚继承是直接扩展父类虚函数表*
* *虚继承的子类也单独保留了父类的vprt与虚函数表*

### C++封装带来的布局成本

非静态数据成员直接包含在每一个类对象中，而成员函数不出现在类对象中，这些函数(non-inline)属于类而不属于类对象，只会为类产生唯一的函数实例。所以封装并没有带来任何空间或执行期的效率影响，而在下面这两种情况下，C++的封装额外成本才会显示出来：
* 虚函数机制（virtual function） , 用以支持执行期绑定，实现多态
* 虚基类 （virtual base class） ，虚继承关系产生虚基类，用于在多重继承下保证基类在子类中拥有唯一实例

C++中处在同一个访问标识符（public、private、protected）下的声明的数据成员，在内存中必定保证以其声明顺序出现。而处于不同访问标识符声明下的成员则无此规定。不考虑虚函数与虚继承，当数据都在同一个访问标识符下，C++的类与C语言的结构体在对象大小和内存布局上是一致的，C++的封装并没有带来空间时间上的影响。

### c++重载、覆盖、隐藏的区别和执行方式

* **成员函数被重载的特征**
1. 相同的作用域（在同一个类中）
2. 函数名字相同，参数不同，返回值可以不同
3. virtual关键字可有可无

* **“覆盖”是指派生类函数覆盖基类函数**
1. 不同的作用域（分别位于派生类与基类）
2. 函数名字相同，参数相同，返回值相同
3. 基类函数必须有virtual 关键字

* **“隐藏”是指派生类的函数屏蔽了与其同名的基类函数**
1. 如果派生类的函数与基类的函数同名，但是参数不同，此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）
2. 如果派生类的函数与基类的函数同名，但是参数相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）

* **三种情况的执行**
1. 重载：看参数
2. 隐藏：用什么就调用什么
3. 覆盖：调用派生类
