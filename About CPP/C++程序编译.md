### C++程序编译过程
---

一般可以分三步：

#### 预处理阶段

主要进行源码级别上的操作，预处理器执行源码中的预处理命令，比如处理宏定义、条件编译命令、包含头文件。。。。

#### 编译、优化、汇编

每一个cpp文件就是一个编译单元，编译过程是分模块进行的，每个模块独立编译，编译过程会进行词法检查、语法检查等，生成汇编代码文件，并优化汇编代码，然后经过汇编程序翻译成目标机器代码（.o或.obj文件）。

#### 链接

因为每个模块是独立编译的，所有对于定义在其他模块中的函数或变量的使用都是未定义的，编译时检查到有声明只是告诉模块--这个函数或变量定义在其它模块中了，当然这样编译后生成的文件是无法直接执行的，所以需要将各个编译后的模块组合起来，并将各个模块中对其它模块的函数调用或变量引用设置到正确的地址，这个过程就叫做链接，链接完各个.obj或.o文件后才能生成一个可执行文件。

链接过程：
1. 确定每一个编译单元在可执行文件中的位置；
2. 查看每一个模块的重定向表，给需要重定向的值加上它所在模块在可执行文件中的起始位置，形成正确的地址；
3. 检查所有模块的导出符号表（是否有符号重复），在导出符号表中搜索未解决符号表中的符号，找到后会在相应位置填上正确地址。

链接方式：
1. 静态链接：函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中，这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。所谓静态库，是在链接阶段，会将汇编生成的目标文件.o与引用到的静态库一起链接打包到可执行文件中。
静态库有以下特点：
* 程序在运行时与函数库再无瓜葛，移植方便
* 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件
* 静态库对程序的更新、部署和发布会带来麻烦，因为如果静态库更新了，所有使用它的应用程序都需要重新编译、发布

2. 动态链接：函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。**动态库在程序编译时并不会被链接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题，同时也解决了静态库对程序的更新、部署和发布带来的麻烦，只需要更新动态库即可。**
动态库的特点：
* 动态库把对一些库函数的链接载入推迟到程序运行的时期
* 可以实现进程之间的资源共享
* 便于程序升级

* **三个链接表**
链接过程需要编译时收集每一个模块的相关信息才能完成，编译每一个模块的同时还要生成三个表供链接过程使用：
1. 导出符号表：提供了在本编译单元中定义，并且可以提供给其他编译单元使用的符号及其地址
2. 未解决符号表：提供了所有在该编译单元里引用，但是定义并不在本编译单元里的符号及其出现的地址
3. 地址重定向表：地址重定向表提供了本编译单元所有对自身地址的引用的记录。链接器进行链接的时候，首先决定各个目标文件在最终可执行文件里的位置。然后访问所有目标文件的地址重定向表，对其中记录的地址进行重定向，即加上该编译单元实际在可执行文件里的起始地址，然后遍历所有目标文件的未解决符号表，并且在所有的导出符号表里查找匹配的符号，并在未解决符号表中所记录的位置上填写实际的地址（也要加上拥有该符号定义的编译单元实际在可执行文件里的起始地址）。最后把所有的目标文件的内容写在各自的位置上，再做一些别的工作，就生成了可执行文件。

* **内部链接和外部链接**
1. 外部链接：一个编译单元中能向其他编译单元提供其定义，让其他编译单元使用的的函数或变量就是外部链接，例如全局变量。如果一个名称对编译单元来说不是局部的，而在链接的时候其他的编译单元可以访问它，也就是说它可以和别的编译单元交互。**外部链接的符号，可以在整个程序范围内使用（因为导出了符号），但是同时要求其他的编译单元不能导出相同的符号（否则会符号冲突）**

2. 内部链接：编译单元中不能向其他编译单元提供其定义的函数或变量就是内部链接，例如static函数，inline函数等。如果一个名称对编译单元来说是局部的，在链接的时候其他的编译单元无法链接到它且不会与其它编译单元中的同样的名称相冲突。**内部链接的符号，不能在别的编译单元内使用，但是不同的编译单元可以拥有同样名称的内部链接符号，却不会发生符号冲突**

C++一般情况下：
1. **用extern关键字修饰的符号是外部链接**，它告诉编译器，这个符号定义在其它模块，应该把这个符号放入未解决符号表。
2. **用static关键字修饰的符号都是内部链接符号**，也就是说这些符号仅仅在模块内部可见，不能在别的编译单元中使用，也就不会被放进导出符号表。
3. **默认情况下，const常量是内部链接**，不会被加到导出符号表中；而**函数和全局变量都是外部链接符号**，这些符号会被放入模块的导出符号表，以供其它模块使用，但是可以用static关键字修饰，把它变成内部链接，这样就不会被放进导出符号表

### C++常见的编译问题
---

* **内联函数需要把定义一起放在头文件中**
内联函数的替换是在编译时执行的，因为每个模块都是独立编译的，此时如果模块本身不知道函数的定义，也就无法内联展开了。编译器将内联函数视为内链接，所以在头文件中包含定义不会产生重定义的问题。
如果没有把内联函数的定义放在头文件，因为内联函数是内部链接，所以这个函数符号在导出符号表中找不到，因为找不到内联函数的定义而无法内联展开，出现链接错误

* **模板类与模板函数也需要把定义一起放在头文件中**
函数模板、类模板只有在调用时才会被实例化，根据具体类型生成相应的代码。为了能在编译时能生成相应实现代码，就需要知道模板函数的定义，这也就要求模板类或模板函数的定义也要一起放在头文件中。如果没放在头文件，编译时编译单元找不到模板类（模板函数）的定义，会认为是定义在其他编译单元了。然而链接程序在导出符号表中找不到这个模板类（模板函数），因为它根本没有被实例化过，会出现链接错误。

* **重定义错误**
可能在不同的编译单元中重复定义了具有外部链接的函数或变量，链接器在链接时会找到多个一样的函数或变量定义。

* **无法解析的外部符号**
可能只出现了函数或变量的声明，没有提供定义，或者声明和定义的原型不一样，导致链接器找不到定义，出现无法解析外部符号的错误。

### 关于编译器
---

#### gcc和g++

* **gcc和g++两者都既能编译C代码又能编译C++代码**
1. 后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序
2. 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库链接，所以通常用g++来完成链接，但是也可以使用gcc来连接，需要加上 -lstdc++选项
3. extern "C"和gcc/g++没有关系，无论是gcc还是g++，用extern "c"时，都是以C的命名方式来为symbol命名，否则都以c++方式命名。

### 关于gdb调试
---

* **gdb常用命令**
1. list：从第一行开始列出原码；r：运行程序（run命令简写）；n：单条语句执行（next命令简写）；c：继续运行程序（continue命令简写）
2. break+行数（或函数名或内存地址）：设置断点；info break：查看断点信息
3. p+变量名：打印变量的值（print命令简写）
4. bt：查看函数堆栈；finish：退出函数

* **使用gdb**
1. **加入调试信息**
编译时（gcc/g++）使用-g参数把调试信息加到可执行文件中。

2. **启动gdb**
使用**gdb  + program + core*，core是程序core dump后产生的文件。

3. **设置断点**
可以在源文件某一行或函数入口主停住，或在程序运行的某个内存地址出停住（break命令）。
4. **设置观察点（watchpoint）**
观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化马上停住程序：
**watch <expr>** ： 一旦表达式expr值有变化时，马上停住程序
**rwatch <expr>** ： 当表达式（变量）expr被读时，停住程序
**awatch <expr>** ：当表达式（变量）的值被读或被写时，停住程序
**info watchpoints** ：列出当前所设置了的所有观察点

5. **设置捕捉点**
设置捕捉点来补捉程序运行时的一些事件，如：载入共享库（动态链接库）或是C++的异常，格式为 **catch <event>**，当event发生时停住程序。event关键字可以是**throw、catch、fork、load**等。

6. **查看栈信息**
当程序被停住了，需要做的第一件事就是查看程序是在哪里停住的。当程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中，可以使用**backtrace**来查看函数调用栈的信息。

7. **查看运行时数据**
当程序停住时，除了查看函数调用栈信息，还可以使用**print**命令来查看当前的运行数据（表达式、程序变量），格式是**print <expr>**。或者直接使用**examine**命令来查看某个内存地址中的值，或使用**info registers**来查看寄存器的情况。

8. **改变程序的执行**
使用GDB挂上被调试程序，当程序运行起来后，可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路（跳转执行、强制调用函数、强制函数返回）或是其变量的值。比如，可以在程序的一次运行中走遍程序的所有分支。
