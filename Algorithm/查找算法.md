## 二分查找
---

> *说明：元素必须有序，如果无序则要先进行排序，时间复杂度为O（logn）。对于频繁插入、删除数据集来说，维护有序代价太大，不适合二分查找*

* **基本思想**
用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

## 插值查找
---

* **基本思想**
基于二分查找，将查找点的选择由1/2改为自适应选择，这样查找点的值变化更加接近关键字key，提高了查找效率。
> *说明：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必合适*

## 分块查找（索引查找）
---

* **算法思想**
将n个数据元素**“按块有序”**划分为m块，每一块中元素不必有序，但块于块之间必须**按块有序**：即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字，以此类推............

* **算法流程**
1. 先选取各块中最大的关键字来构成一个索引表；
2. 查找分为两部分：先对索引表进行二分或顺序查找，确定待查记录在哪一个块中；再对已经确定的块进行顺序查找。

## 哈希查找
---
> *哈希表通过哈希函数在关键字和存储位置之间建立了对应关系，在时间和空间上做出了平衡，是一种以空间换时间的算法。更详细的解释见[链接](http://blog.jobbole.com/79261/)*

* **哈希存储和查找的过程**
1. 使用哈希函数将被查找的键转换为数组的索引，在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下需要处理多个键被映射到同一个索引值的情况，哈希查找的第二个步骤就是处理这种冲突。
2. 处理哈希碰撞冲突。（拉链法、线性探测法）

* **哈希函数**
哈希函数需要易于计算，并且能够均匀分布所有的键（越均匀出现冲突的几率就越小）。获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。将字符串作为键的时候，也可以将他作为一个大的整数，采用保留除余法。可以将组成字符串的每一个字符取值然后进行哈希，或者间隔取N个字符来获取哈希值（节约计算时间）。

* **处理碰撞冲突**

1. **链地址法**
将大小为M 的数组（链表数组）的每一个元素指向一个链表，链表中的每一个节点都存储了散列值为该索引的键值对，这就是拉链法。选择足够大的M可以使所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到等应的链表，然后沿着链表顺序找到相应的键。

![采用拉链法的存储结构](http://upload-images.jianshu.io/upload_images/7109298-224c69b7601f97bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2. **线性探测法**
线性探测法是*开放寻址法* 解决哈希冲突的一种方法。使用大小为M的数组来保存N个键值对（M>N），用数组中的空位解决碰撞冲突。当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1。

![线性探测法存储结构](http://upload-images.jianshu.io/upload_images/7109298-3ab9c674b493524f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 树表查找
---

### 二叉树查找
> *太简单，没啥子好说的*

### 2-3树

* **2-3查找树性质**
1. 中序遍历2-3树，可以得到排好序的序列；
2. 完全平衡的2-3树中，根节点到每一个空节点的距离相等；
3.查找、插入效率和树的高度相关。

### 红黑树

* **基本思想**
红黑树的思想就是对2-3查找树进行编码，即对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接用来链接两个2-nodes节点来表示一个3-nodes节点，黑色链接用来链接普通的2-3节点，也就是使用向左倾斜红色链接的两个2-节点来表示一个3-节点，这样一个2-节点又是另一个2-节点的左子节点。

* **性质**
1. 整个树完全黑色平衡，从根节点到叶子节点的路径上黑色链接的个数相同，个数相等；
2. 树平均高度为logN，保证最坏情况下任然具有对数的时间复杂度。

### B树、B+树

> *B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作*

* **B和B+树的区别**
B+树的非叶节点只包含导航信息（具有索引作用），不包含实际的值，跟记录相关的信息都放在叶节点中；所有的叶节点构成一个有序链表（顺序访问指针），可以按照关键码排序的次序遍历全部记录。

* **B树的优点**
由于每一个节点都包含key和value，所以经常访问的元素可能距离根节点更近，访问更快。

* **B+树优点**
1. 由于B+树在非叶节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性，访问叶子几点上关联的数据也具有更好的缓存命中率。
2. B+树的叶子结点都是相链的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

### 树表查找总结
二叉查找树平均查找复杂度为O(logn)，但是最坏情况会退化为O(n)。平衡查找树中的2-3查找树，在插入节点之后能够进行自平衡操作，从而保证了树的高度在一定的范围内，进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种统计性能比较高的平衡查找树。
