# **快速排序**
---
## Partion算法
### Partion思想

首先从无序数组中选出枢轴点 pivot，然后通过一趟扫描（**从数组的两端交替向中间扫描**），以 pivot 为分界线将数组中其他元素分为两部分，使得左边部分的数小于等于枢轴，右边部分的数大于等于枢轴（左部分或者右部分都可能为空），最后返回枢轴在新的数组中的位置。

```cpp
int partition(vector<int>&arr, int begin, int end)
{
    int pivot = arr[begin];
    while(begin < end)
    {
        while(begin < end && arr[end] >= pivot)
           end--;
        arr[begin] = arr[end];
        while(begin < end && arr[begin] <= pivot)
           begin++;
        arr[end] = arr[begin];
    }
    arr[begin] = pivot;
    return begin;
}
```

### **Partion应用**

#### **快排**

> *分治思想：1.从数列中取出一个数作为中轴数(pivot)；2.将比这个数大的数放到它的右边，小于或等于它的数放到它的左边；3.再对左右区间重复第三步，直到各区间只有一个数。*

* *代码实现*

```cpp
void quick_sort(vector<int> &arr, int begin, int end){
    if(begin >= end){
        return;
    }
    int pos = partition(arr, begin, end);
    quick_sort(arr, begin, pos-1);
    quick_sort(arr, pos+1, end);
}
```

* *性能优化*

1. 优化选取枢轴，三数取一（三平均分区法）

> *在一般的的快速排序中，选择的是第一个元素作为中轴(pivot),这会出现某些分区严重不均的极端情况，比如划分为了1和n-1两个序列，从而导致出现最坏的情况。三平均分区法与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。*
2. 优化递归操作，采用尾递归
3. 当划分到较小的子序列时，通常可以使用插入排序替代快速排序

> *对于较小的子序列（通常序列元素个数为10个左右），就可以采用插入排序直接进行排序而不用继续递归*


#### **从无序数组中寻找第K小的值**

> *用 partition 将数组分为两部分，得到分界点下标 pos:pos == k-1，则找到第 K 大的值，arr[pos]；pos > k-1，则第 K 大的值在左边部分的数组；pos < k-1，则第 K 大的值在右边部分的数组*

* *代码实现*

```cpp
int find_kth_number(vector<int> &arr, int k){
    int begin = 0, end = arr.size();
    assert(k>0 && k<=end);
    int target_num = 0;
    while (begin < end){
        int pos = partition(arr, begin, end);
        if(pos == k-1){
            target_num = arr[pos];
            break;
        }
        else if(pos > k-1){
            end = pos;
        }
        else{
            begin = pos + 1;
        }
    }
    return target_num;
}
```

# **堆排序**
---

* **what is 堆**

堆是一种特殊的完全二叉树，所有的父节点都比子节点要小（大）。使用一维数组来存储有N个节点的完全二叉树（下标从1开始），则最后一个非叶节点的编号为N/2，编号为i的节点，其左子节点的编号为2*i（2*i < N），右子节点编号为2*i+1（2*i+1 < N）。下图是一个最小堆：

![最小堆](http://upload-images.jianshu.io/upload_images/7109298-c1c345dcb60de68c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


* **建立堆**

把n个元素建立一个堆，首先我可以将这n个结点以自顶向下、从左到右的方式从1到n编码。这样就可以把这n个结点转换成为一棵完全二叉树（存储在一维数组中）。紧接着从最后一个非叶结点（结点编号为n/2）开始到根结点（结点编号为1），逐个扫描所有的结点，根据需要将当前结点向下调整，直到以当前结点为根结点的子树符合堆的特性（所有的父节点都比子节点要小/大）。

*建立堆的代码*

```cpp
for(i=n/2;i>=1;i--)
    siftdown(i);
```

*向下调整的代码*

```cpp
void siftdown(int i) //传入一个需要向下调整的结点编号i，这里传入1，即从堆的顶点开始向下调整 
{
    int t,flag=0;//flag用来标记是否需要继续向下调整 
    //当i结点有儿子的时候（其实是至少有左儿子的情况下）并且有需要继续调整的时候循环窒执行
    while( i*2<=n && flag==0 )
    {        
        //首先判断他和他左儿子的关系，并用t记录值较小的结点编号 
        if( h[ i] > h[ i*2] )
            t=i*2;
        else
            t=i; 
        //如果他有右儿子的情况下，再对右儿子进行讨论 
        if(i*2+1 <= n)
        {
            //如果右儿子的值更小，更新较小的结点编号  
            if(h[ t] > h[ i*2+1])
                t=i*2+1;
        }
        //如果发现最小的结点编号不是自己，说明子结点中有比父结点更小的  
        if(t!=i)
        {
            swap(t,i);//交换它们，注意swap函数需要自己来写
            i=t;//更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整 
        }
        else
            flag=1;//则否说明当前的父结点已经比两个子结点都要小了，不需要在进行调整了 
    }
}
```

* **堆删除/添加元素**
1. 删除元素

最小/大的数就在堆顶，假设存储这个堆的数组叫做h的话，最小/大数就是h[ 1]。将堆顶的数删除，并将h[n--]放到堆顶h[1]，显然此时已经不符合最小/大堆的特性，需要将h[1]向下调整到合适的位置，讲h[1]和其两个孩子节点相比较，选择较小/大的一个与它交换。继续向下调整。

2. 添加新元素

直接将新元素插入到末尾，再根据情况判断新元素是否需要上移，直到满足堆的特性为止。如果堆的大小为N（即有N个元素），那么插入一个新元素所需要的时间也是O(logN)。向上调整的代码如下：

```cpp
void siftup(int i) //传入一个需要向上调整的结点编号i
{
    int flag=0; //用来标记是否需要继续向上调整
    if(i==1)  return; //如果是堆顶，就返回，不需要调整了    
    //不在堆顶 并且 当前结点i的值比父结点小的时候继续向上调整 
    while(i!=1 && flag==0)
    {
        //判断是否比父结点的小 
        if(h[ i]<h[ i/2])
            swap(i,i/2);//交换他和他爸爸的位置 
        else
            flag=1;//表示已经不需要调整了，当前结点的值比父结点的值要大 
        i=i/2; //这句话很重要，更新编号i为它父结点的编号，从而便于下一次继续向上调整 
    }
}
```

* **堆排序**

> *和快速排序一样堆排序的时间复杂度也是O(NlogN)*

比如要进行从小到大排序，可以先建立最小堆，然后每次删除顶部元素并将顶部元素输出或者放入一个新的数组中，直到堆为空为止。最终输出的或者存放在新数组中数就已经是排序好的了。

堆排序还有一种更好的方法，从小到大排序的时候不建立最小堆而建立最大堆。最大堆建立好后，最大的元素在h[ 1]。因为我们的需求是从小到大排序，希望最大的放在最后。因此我们将h[ 1]和h[ n]交换，此时h[ n]就是数组中的最大的元素。请注意，交换后还需将h[ 1]向下调整以保持堆的特性。OK现在最大的元素已经归位，需要将堆的大小减1即n--，然后再将h[ 1]和h[ n]交换，并将h[ 1]向下调整。如此反复，直到堆的大小变成1为止。此时数组h中的数就已经是排序好的了。代码如下：

```cpp
//堆排序
void heapsort()
{
    while(n>1)
    {
        swap(1,n);
        n--;
        siftdown(1);
    }
}
```

# **归并排序**
***

* **归并思想**

归并排序使用了递归分治的思想。先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。倒着来看，其实就是先两两合并，然后四四合并。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。

> *2路归并：假设初始序列有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1,然后两两归并，得到[n/2]个长度为2或1的有序子序列；再两两归并，...............，重复直到得到一个长度为n的有序序列为止*

* **算法步骤**
1. 申请合并空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；
4. 重复步骤3直到某一指针达到序列尾；
5. 将另一序列剩下的所有元素直接复制到合并序列尾。


# **冒泡排序**
---

* **冒泡思想**

大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面，这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6，3和4无需交换。5和3交换，变成3,5,4,8,6，这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。

# **简单选择排序**
---

* **选择排序思想**

和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)。

# **conclusion**
---
* **简单排序方法**
1. 冒泡
2. 简单选择
3. 直接插入

* **改进排序算法**
1. 堆排序
2. 归并排序
3. 快速排序
