> *有这样一个题目：给定整形参数N，求出自然数中小于N的质数，或最小的N个质数*

### 很暴力的解决办法：试除法
不断地尝试能否整除，比如要判断自然数 x 是否质数，就不断尝试小于 x 且大于1的自然数，只要有一个能整除，则 x 是合数；否则，x 是质数。问题在于，需要从2一直尝试到x-1吗？

### 大佬们的牛逼解法：筛法
首先，2是公认最小的质数，先把所有2的倍数去掉；然后剩下的那些大于2的数里面，最小的是3，所以3也是质数；然后把所有3的倍数都去掉，剩下的那些大于3的数里面，最小的是5，所以5也是质数......不断重复上面的过程，就可以把某个范围的合数去掉只剩下质数。该方法是古希腊的一位大佬发明的——艾拉托斯特尼

* **确定质数的分布范围**

如果要求计算出从小到大的N个素数，就需要先估算出这N个素数会分布在多大的范围。
素数定理：素数的分布是越往后越稀疏，正整数N以内的素数大约有N/ln(N)个，估算的范围越大偏差越小。有了素数定理，就可以根据要计算的素数个数，反推出这些素数分布在多大的范围内。素数分布公式有一定的误差（通常小于15%）。为了保险起见，应该把反推出的素数分布范围再稍微扩大15%。

* **设计存储容器**
1. 使用整型的容器。在筛的过程中把发现的合数删除掉，最后容器中就只剩下质数了。N很大时，这种方法会浪费大量的内存空间，而频繁的内存分配/释放，会增加CPU开销并可能造成内存碎片。
2. 使用定长的布尔型容器（数组）。比如构造大小为N的布尔型数组，所有元素都初始化为true，在筛的过程中，一旦发现某个自然数是合数，就以该自然数为下标，把对应的布尔值改为 false。全部筛完之后，遍历数组，找到那些值为 true 的元素，把他们的下标打印出来即可。
如果想要继续优化存储空间，可以使用按位（bit）存储的方法，在C++里一个字节占8个bit，每个比特可以表示0或1，可以构造一个定长的byte数组，每个byte存储8个布尔值，空间性能提高了8倍。
