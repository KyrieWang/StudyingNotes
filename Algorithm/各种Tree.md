## 二叉搜索树BST
---

* **性质**

1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点（no duplicate nodes）；
5. 最左和最右节点为最小值和最大值。

* **查找BST中元素**

在二叉搜索树b中查找x的过程为：
1. 若b是空树，则搜索失败，否则：
2. 若x等于b的根节点的数据域之值，则查找成功；否则：
3. 若x小于b的根节点的数据域之值，则搜索左子树；否则：
4. 查找右子树。

* **往BST中插入元素**

向一个二叉搜索树b中插入一个节点s的算法，过程为：
1. 若b是空树，则将s所指结点作为根节点插入，否则：
2. 若s->data等于b的根节点的数据域之值，则返回，否则：
3. 若s->data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：
4. 把s所指节点插入到右子树中（新插入节点总是叶子节点）。

## 2-3树
---

* **2-3树定义**

1. 要么为空，要么：
2. 对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key小，右节点也是一个2-3节点，所有的值比key要大。
3. 对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。

* **2-3树查找**

2-3树的查找和二叉查找树类似，要确定一个树是否属于2-3树，首先和其跟节点进行比较，如果相等，则查找成功；否则根据比较的条件，在其左中右子树中递归查找，如果找到的节点为空，则未找到，否则返回。

* **2-3树插入**

1. 往一个2-node节点插入

往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一个2-node节点，那么很容易，我们只需要将新的元素放到这个2-node节点里面使其变成一个3-node节点即可。但是如果查找的节点结束于一个3-node节点，那么可能有点麻烦。

2. 往一个3-node节点插入

构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中.一直向上不断分解临时的4-结点并将中键插入更高的父结点，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。

3. 总结

总结起来就是：先找插入结点，若结点有空(即2-结点)，则直接插入。如结点没空(即3-结点)，则插入使其临时容纳这个元素（成为临时的4-节点），然后分裂此结点，把中间元素移到其父结点中。对父结点亦如此处理。（中键一直往上移，直到找到空位，在此过程中没有空位就先构建一个临时的4-节点，再分裂。）。具体分析见[链接](http://blog.csdn.net/yang_yulei/article/details/26066409)。

## B树
---

> *一种平衡的多路查找树，B树的结构提供了内外存间的数据交互，主要应用于文件系统和数据库索引。磁盘页对应树节点，最坏情况下，查询的磁盘IO次数对应树的高度*

* **B树属性**

1. 根结点若不是叶节点，至少有两个棵子树；
2. 每个中间节点都包含k-1个元素和k个孩子；
3. 每一个叶子节点都包含k-1个元素；
4. 所有的叶子结点都位于同一层；
5. 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。

* **查找**

首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：

```cpp
BTree_Search(node, key)
{
    if(node == null) return null;
 
    foreach(node.key)
    {
        if(node.key[i] == key) return node.data[i];
        if(node.key[i] > key) return BTree_Search(point[i]->node);
    }
 
    return BTree_Search(point[i+1]->node);
}
data = BTree_Search(root, my_key);
```

* **插入/删除操作**

> *代码太麻烦了，了解原理就行，还是看[链接](http://blog.jobbole.com/111757/?utm_source=blog.jobbole.com&utm_medium=relatedPosts)吧*

## B+树
---

> *和MySQL索引相关，直接写到了MySQL索引原理那一篇，也可以看[链接](http://blog.jobbole.com/24006/)*

* **B+树与B树的差异**

1. 有k个子结点的结点必然有k个关键码；
2. 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中；
3. 叶结点增加了顺序访问指针，树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

* **B+树的优点**

1. 由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。
2. B+树的叶子结点都是相连的（每个叶子节点都有指向相邻叶子节点的顺序访问指针），因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

## 红黑树
---

> *理解红黑树：红黑树就是用红链接来表示3-节点的2-3树，对红黑树的插入、构造等可以用2-3树的方法来操作，得到结果以后再把结果中的3-节点转化为红链接。红黑树既是二叉查找树，也是2-3树*

* **红黑树定义**

红黑树的思想是用标准的二叉查找树（只有2-节点）和一些额外信息（替换3-节点）来表示2-3树。树中的红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接，即用左斜的红色链接相连的两个2-节点来表示3-节点。红黑树满足以下条件：
1. 红链接均为左连接；
2. 没有任何一个结点同时和两条红链接相连；
3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。

* **插入操作**

向红黑树中插入操作时，等同于2-3树的插入操作。红黑树与2-3树在本质上是相同的，只是它们对3结点的表示不同。向一个只含有一个2-结点的2-3树中插入新键后，2-结点变为3-结点，再把这个3-结点转化为红结点即可。


![红黑树插入操作](http://upload-images.jianshu.io/upload_images/7109298-b28567b22019cc45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* **为什么STL和linux都使用红黑树作为平衡树的实现，而不是更加平衡的AVL树？**

虽然AVL树比红黑树更加平衡，查找的效率更高，但在大量的插入删除操作时，更容易引起树的非平衡，所以AVL树需要rebalance的频率比红黑树高。所以在大量插入删除时，红黑树比AVL更加高效。折衷选择下，红黑树的性能比AVL要高。

* **红黑树在C++ map、set中的应用**
> *map、set内部结构采用红黑树，详细分析可以看[链接](http://www.cnblogs.com/renyuan/archive/2013/12/11/3469851.html)*

1. **map、set的插入删除效率比其它顺序容器要高**

关联容器不需要内存拷贝和内存移动，map、set内的所有元素都是以节点的方式存储，节点结构和链表的相似。在插入删除操作的时候，只需要改变指针指向的节点，和内存移动无关。顺序容器则不一样，比如vector的扩容问题。

2. **每次insert之后，迭代器不会失效**

3. **map无法像vector一样预先分配数据**

4. **当数据增多时， map、set的插入、搜索速度变化不大**
