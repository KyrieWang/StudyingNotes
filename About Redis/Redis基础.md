# **Redis数据类型**
***
## keys

key是字符串类型（非二进制安全的字符类型），像“my key”和“mykey\n”这样包含空格和换行的key是不允许的。在使用的时候可以自己定义一个Key的格式，例如 object-type:id:field 。
Key不要太长，占内存，查询慢
Key不要太短，u:1000:pwd 不如 user:1000:password 可读性好

## value

1. string
2. list
3. set
4. sorted set
5. hash
# **Redis持久化**
***
## RDB快照

* **RDB快照的运作方式**

当 Redis 需要保存 dump.rdb 文件时，服务器执行以下操作：
1.  Redis调用 fork() ，同时拥有父进程和子进程
2. 子进程将数据集写入到一个临时 RDB 文件中
3. 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件
* **RDB优点**
1. RDB文件适合用于备份、灾难恢复
2. RDB最大化了Redis的性能，因为Redis父进程持久化时唯一需要做的是启动(fork)一个子进程，由子进程完成所有剩余工作。父进程实例不需要执行像磁盘IO这样的操作
3. RDB在重启保存了大数据集的实例时比AOF要快

* **RDB缺点**

1. 数据丢失。如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。
2. 数据集很大的话，fork()比较耗时。

## AOF日志

* AOF日志运作方式

AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾

* AOF优点

1. 使用AOF Redis会更具有可持久性(durable)，有不同的fsync策略:
* *每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全*
* *每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据*
* *从不 fsync ：将数据交给操作系统来处理。更快，也更不安全的选择*

2. AOF文件里面包含一个接一个的操作，以易于理解和解析的格式存储;当AOF文件变得很大时，Redis会自动在后台进行重写。

* AOF缺点

1. 对同样的数据集，AOF文件通常要大于等价的RDB文件
2. AOF可能比RDB慢，这取决于准确的fsync策略
* AOF日志重写
> *Redis 可以在后台对 AOF 文件进行重写,使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小*

重写过程：
1. Redis调用fork()
2. 子进程开始向一个临时文件中写AOF
3. 父进程在一个内存缓冲区中积累新的变更(同时将新的变更写入旧的AOF文件，所以即使重写失败也安全)
4. 当子进程完成重写文件，父进程收到一个信号，追加内存缓冲区到子进程创建的文件末尾
5. Redis原子性地重命名旧文件为新的，然后开始追加新数据到新文件

# **Redis主从复制**
***

* **工作原理**
 
从服务器在连接时发送了一个SYNC命令，然后主服务器开始后台存储，并且开始缓存新连接进来的修改数据的命令。**当后台存储完成后，主服务器把数据文件发送到从服务器，从服务器将其保存在磁盘上，然后加载到内存中**。然后主服务器把刚才缓存的命令发送到从服务器。这是作为命令流来完成的，并且和Redis协议本身格式相同。

* **部分重新同步**

如果遭遇连接断开，重新连接之后可以从中断处继续进行复制，而不必重新同步。**主服务器端为复制流维护一个内存缓冲区（in-memory backlog）。主从服务器都维护一个复制偏移量（replication offset）和master run id ，当连接断开时，从服务器会重新连接上主服务器，然后请求继续复制，假如主从服务器的两个master run id相同，并且指定的偏移量在内存缓冲区中还有效，复制就会从上次中断的点开始继续**。如果其中一个条件不满足，就会进行完全重新同步。

* **主服务器不进行持久化时复制的安全性**

在进行主从复制设置时，应该在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。**关闭持久化并允许自动重启的主服务器，在做主从同步时，可能导致所有服务器的数据都被清空。**

* **主从复制的性能问题**

1. master最好不要做任何持久化工作，特别是内存快照（会阻塞线程），slave可以开启AOF，每秒同步一次。
2. 主从不要用图结构，单向链表更稳定（方便解决单点故障，实现slave替换master）。
* **单master、单slave的主从保证高可用性**
master宕掉之后，集群对外只提供读服务，master重启之后再继续更新操作；之前的更新用MQ缓存，master启动之后再笑话故障期间的更新。

# **Redis优化**
***

## Redis性能问题排查

### 性能相关指标及优化

> *参考[Redis性能问题排查](http://www.cnblogs.com/mushroom/p/4738170.html)*

* **memory：内存使用率used_memory**

> *内存交换引起的性能问题*

内存使用率是Redis服务最关键的一部分。如果一个Redis实例的内存使用率超过可用最大内存	，那么操作系统开始进行内存与swap空间交换，把内存中旧的或不再使用的内容写入硬盘上（硬盘上的这块空间叫Swap分区），以便腾出新的物理内存给新页或活动页(page)使用。

如果Redis进程上发生内存交换，那么Redis和依赖Redis上数据的应用会受到严重的性能影响。 通过查看used_memory指标可知道Redis正在使用的内存情况，如果used_memory>可用最大内存，那就说明Redis实例正在进行内存交换或者已经内存交换完毕。

通过减少Redis内存占用率，避免发生内存交换：

1. 假如缓存数据小于4GB，就使用32位的Redis实例。因为32位实例上的指针大小只有64位的一半，它的内存空间占用空间会更少些。

2. 尽可能的使用Hash数据结构。因为Redis在储存小于100个字段的Hash结构上，其存储效率是非常高的。

3. 设置key的过期时间。倘若key在明确的时间周期内使用或者旧key不大可能被使用时，就可以用过期时间命令(expire)去设置过期时间，这样Redis会在key过期时自动删除key。 假如知道每秒钟有多少个新key-value被创建，那可以调整key的存活时间，并指定阀值去限制Redis使用的最大内存。

4. 限制Redis使用的最大内存（详细情况见Redis内存管理优化）。

5. 回收key（6种回收策略）。当内存使用达到设置的最大阀值时，需要选择一种key的回收策略，可在Redis.conf配置文件中修改*maxmemory-policy*属性值。若是Redis数据集中的key都设置了过期时间，*volatile-tt*（从已设置过期时间的数据集合中挑选即将过期的数据淘汰）策略是比较好的选择。但如果key在达到最大内存限制时没能够迅速过期，或者根本没有设置过期时间，设置为*allkeys-lru*值比较合适，它允许Redis从整个数据集中挑选最近最少使用的key进行删除(LRU淘汰算法)。

* **内存碎片率**

> *Redis info中的内存碎片是由操作系统分配的内存除以Redis分配的内存得出的。内存碎片率稍大于1是合理的，说明内存碎片率比较低，也没有发生内存交换，如果超过1.5，50%是内存碎片；如果低于1，说明Redis内存分配超出了物理内存，可能发生了内存交换*

**有3种方式来处理内存碎片率的问题：**
1. **重启Redis服务器**。如果内存碎片率超过1.5，重启Redis服务器可以让额外产生的内存碎片失效并重新作为新内存来使用，使操作系统恢复高效的内存管理。在重启前要注意持久化，保证Redis关闭不丢失数据。
2. **限制内存交换**。 如果内存碎片率低于1，Redis实例可能会把部分数据交换到硬盘上。

* **命令处理数total_commands_processed**

> *在Redis实例中，跟踪命令处理总数是解决响应延迟问题最关键的部分，延迟时间增加导致响应时间变慢可能是由于一个或多个慢命令引起的。这时可以看到每秒命令处理数在明显下降，甚至于后面的命令完全被阻塞，导致Redis性能降低。要分析解决这个性能问题，需要跟踪命令处理数的数量和延迟时间。比如可以通过脚本定期记录total_commands_processed的值。当客户端明显发现响应时间过慢时，可以通过记录的total_commands_processed历史数据值来判断命理处理总数是上升趋势还是下降趋势，以便排查问题*

1. **使用命令处理总数解决延迟时间增加**

通过与记录的历史数据比较得知，命令处理总数确实是处于上升或下降状态，那么可能是有2个原因引起的:
* 命令队列里的命令数量过多，后面的命令一直处于等待
* 慢命令阻塞了Redis

有以下3个办法可以解决上面两条原因引起的响应延迟：

1. **使用多参数命令**：若是客户端在很短的时间内发送大量的命令，会发现响应时间明显变慢，这由于后面命令一直在等待队列中前面大量命令执行完毕。可以通过**单命令多参数的形式取代多命令单参数的形式**。举例来说，循环使用LSET命令去添加1000个元素到list结构中，是性能比较差的一种方式，更好的做法是在客户端创建一个1000元素的列表，用单个命令LPUSH或RPUSH，通过多参数构造形式一次性把1000个元素发送的Redis服务。

2. **管道命令**。另一个减少多命令的方法是使用管道(pipeline)，把几个命令合并一起执行，从而减少因网络开销引起的延迟问题。比如，10个命令单独发送到服务端会引起10次网络延迟开销，使用管道会一次性把执行结果返回，仅需要一次网络延迟开销。

3. **避免操作大集合的慢命令**。操作集合时，高时间复杂度的命令会导致延迟时间增加，所以应该避免使用诸如sort这样高时间复杂度的命令。

## Redis内存管理优化

* 不要开启vm选项。
* 限制物理内存的使用不要超过总容量的3/5。
> *redis.conf中的maxmemory选项，该选项是告诉Redis当使用了多少物理内存后就开始拒绝后续的写入请求，能很好的保护好你的Redis不会因为使用了过多的物理内存而导致swap，最终严重影响性能甚至崩溃。若是启用了Redis快照功能，应该设置“maxmemory”值为系统可使用内存的45%，因为快照时需要一倍的内存来复制整个数据集，也就是说如果当前已使用45%，在快照期间会变成95%(45%+45%+5%)，其中5%是预留给其他的开销*
* 为不同数据类型提供一组参数来控制内存的使用
> *hash:当value这个hashmap内部不超过多少个成员时采用一维线性的紧凑格式来存储map，省去大量指针的内存开销；list也一样，多少节点以下、节点值小于多少时会采用紧凑型格式存储。HashMap的优势是查找和操作的时间复杂度都是O(1)的，而放弃Hash采用一维存储则是O(n)的时间复杂度，如果
成员数量很少，则影响不大，否则会严重影响性能，所以要权衡好这个值的设置，总体上还是时间成本和空间成本上的权衡。*

> *更多Redis优化经验见[链接](http://www.cnblogs.com/mushroom/p/4738170.html)*

# **Redis使用经验**
***

1. 根据业务需要选择合适的数据类型，为不同的应用场景设置相应的紧凑存储参数（内存优化）。
2. 业务场景不需要持久化时关闭所有的持久化方式，以获得最大的性能和内存使用量；若需要持久化，根据是否可以容忍重启丢失部分数据，在快照和AOF选择其一。
