# 事务处理
> 事务是由一组SQL语句组成的逻辑处理单元
***
* **事务的ACID特性**
1. 原子性（Atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
2. 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。
3. 隔离性（Isolation）：隔离性指的是一个事务在最终提交以前，对其他事务时不可见的。数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的。
4. 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。
* **事务并发带来的问题**
1. 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。
2. 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。即一个事务读取了另一个事务操作但未提交的数据。
3. 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！即一个事务中的多个相同查询返回了不同数据。
4. 幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
* **事务的隔离性**
> *四个隔离级别*
1. 读未提交
所有事务都可以看到其他未提交事务的执行结果，当前事务可以读取到其他事务已经修改但还没有提交的数据。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少，该级别引发的问题是——脏读（读取到了未提交的数据）、不可重复读、幻读。
2. 读提交
一个事务只能看见已经提交事务所做的改变（当前事务只可以读取到其他事务已经提交后的数据）。这种隔离级别出现的问题是——不可重复读(Nonrepeatable Read)：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。导致这种情况的原因可能有：(1)有一个交叉的事务有新的commit，导致了数据的改变;(2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit。
3. 可重复读
这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。此级别可能出现的问题——幻读(Phantom Read)：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行，InnoDB和Falcon存储引擎通过多版本并发控制(MVCC)机制解决了该问题。
4. 可串行化
这是最高的隔离级别。它通过强制事务排序（所有的事务会放在一个队列中执行，同一个时间点只能有一个事务操作数据库对象），使之不可能相互冲突，从而解决幻读问题。简言之它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
