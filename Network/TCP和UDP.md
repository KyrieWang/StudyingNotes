## 关于TCP
---

### TCP头的格式

![TCP头](http://upload-images.jianshu.io/upload_images/7109298-1d0dd6dfddac75a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

TCP头中：
* Sequence Number是包的序号，**用来解决网络包乱序的问题**
* Acknowledgement Number就是ACK，**用于接收方确认收到，解决不丢包的问题**
* Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），**用来解决流量控制**
* TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的

### TCP数据包大小

以太网数据包（packet）的大小是固定的1522字节，1500 字节是负载（payload），22字节是头信息（head）；IP 数据包在以太网数据包的负载里面，它的头信息最少需要20字节，所以 IP 数据包的负载最多为1480字节；TCP 数据包在 IP 数据包的负载里面，它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节，由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。

![TCP数据包](http://upload-images.jianshu.io/upload_images/7109298-013ec5a8779c61d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### TCP数据包的编号(seq)

发送数据时，TCP 协议为每个包编号（sequence number），以便接收方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。每个数据包都有两个编号，自身的编号（sequence number）以及下一个包的编号（next sequence number），**next sequence number = sequence number + 当前数据包的负载**。第一个包的编号是个随机数。

### 慢启动和ACK

服务器发送数据太快，可能因为带宽小、路由器缓存溢出等原因而丢包，所以应该在线路允许的情况下慢慢尝试来达到最高速率。TCP 为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。

Linux 内核里面设定了（常量TCP_INIT_CWND），刚开始通信的时候，发送方一次性发送10个数据包，即"发送窗口"的大小为10。然后停下来，等待接收方的确认，再继续发送，这个确认消息简称ACK(acknowledgement)。即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。
ACK包含两个信息：
* 希望要收到的下一个数据包的编号
* 接收方的接收窗口的剩余容量

发送方通过这两个信息和自己已经发送的数据包的最新编号，就能推测出接收方大概的接收速率，从而通过调整发送窗口的大小来降低或提高发送速率。

TCP是双向通信，接收方和发送方都需要发送ACK，每个 ACK 都带有下一个数据包的编号，以及接收窗口的剩余容量，而且两方的窗口大小很可能不一样，ACK通常和数据合并在一个数据包里发送。如下图：

![ACK确认](http://upload-images.jianshu.io/upload_images/7109298-372c6f4bb573d36e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### TCP建立连接、断开连接

#### 建立连接——三次握手

* **TCP三次握手过程**：

1. 第一次握手：客户端请求建立连接时，发送一个syn(syn=1)报文段到服务器，并进入SYN_SEND的状态，等待服务器的确认；
2. 第二次握手：服务器收到SYN报文，为该tcp连接分配缓存和变量，并且向客户端发送一个SYN+ACK的确认报文，然后服务器进入SYN_RCV的状态；
3. 第三次握手：客户端收到服务器的syn+ack确认报文后，也为这个连接分配缓存和变量，并且向服务器发送一个ack确认报文。客户端和服务器进入连接状态。

![三次握手](http://upload-images.jianshu.io/upload_images/7109298-f2d5cf2afefb8067.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


在三次握手的过程中，服务器会维护一个*未连接队列*，这个队列为每个客户端的syn请求报文段建立一个条目，表明服务器已经收到syn报文，并且向客户端发出了确认报文，正在等待客户端的确认。这些条目所标识的连接在服务器处于SYN_RECV的状态，当服务器收到客户端的确认报文，会删除这个条目，进入连接状态。

还有就是建立连接是syn超时，syn-ack重传的问题。服务器想客户端发送syn-ack报文后，如果没有收到客户端的确认包，会重传syn-ack；如果等待一段时间后还是没有收到，会再次重传。如果重传次数超过系统的最大重传次数，会把这条连接信息从未连接队列里删除。
> *在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，才会放弃这个连接*

* **三次握手的原因**

三次握手的目的主要有两个：一是同步连接双方的序列号和确认号，作为以后数据通信的序号，保证收到的数据不会因为网络传输的问题而乱序，并且交换TCP窗口大小信息；二是为了防止已经失效的连接请求报文突然又被传送到了服务端而产生错误。

同步序列号、确认号的过程是这样的：
1. 客户端向服务器发送一个syn置位成1的报文，其中包括它的初始序列号seq=X、确认序列号ack=0，和一个窗口大小（表示客户端的接收缓冲区大小）；
2. 服务器收到客户端的syn报文后，向客户端发送一个syn和ack都置为成1的报文，其中包括它选择的初始序列号Y、对客户端的确认序列号X+1和一个窗口大小（表示服务器的接收缓冲区大小）；
3. 客户端收到服务器的syn+ack报文后，想服务器发送一个确认号是Y+1、序号是X+1的ack报文，至此连接完成。

如果改成两次握手，可能造成死锁，比如这种情况：
> 假如客户端给服务端发送一个连接请求的分组，服务器收到了这个分组，并且向客户端发送了确认应答分组。按照两次握手协定的话，服务器会认为连接已经建立好了，可以开始发送分组数据，但是在应答分组在传输中被丢失的情况下，客户端将不会知道服务器是否准备好了，更不知道服务器的序列号。这种情况下，客户端会认为连接还没有建立，将会忽略服务器发送过来的任何数据分组，只等待应答确认分组，而服务器在发出的数据分组超时后，会重复发送同样的分组，这样就形成了死锁。

#### 断开连接——四次挥手

> *因为TCP是全双工的，所以每个方向都必须单独关闭，当其中一方完成它的数据发送任务后就能发送一个FIN分组来终止这个方向的连接。收到一个FIN分组只表示这一方向上没有数据流动，另一方收到FIN分组后依然可以发送数据。首先关闭的一方执行主动关闭，另一方执行被动关闭*

* **四次挥手过程**

有两个主机，主机1和主机2（可以是客户端也可以是服务端），主机1主动关闭连接的过程如下：
1. 第一次挥手：主机1发送一个FIN报文给主机2，表示主机1 没有数据要发送给主机2了，此时主机1进入FIN_WAIT_1状态；
2. 第二次挥手：主机2收到了主机1发送的FIN报文后，向主机1回一个ACK报文，此时主机2进入CLOSE_WAIT状态，相当于主机2告诉主机1，同意关闭连接的请求，此时主机1进入FIN_WAIT_2状态；
3. 第三次挥手：主机2向主机1发送FIN报文，请求关闭连接，此时主机2进入LAST_ACK状态；
4. 第四次挥手：主机1收到主机2的FIN报文后，向主机2发送ACK确认报文，**然后主机1进入TIME_WAIT状态**；主机2收到主机1的ACK报文后就关闭连接；此时，主机1等待2MSL时间后如果没有收到什么回复，就证明主机2已正常关闭，然后主机1也可以关闭连接了。

> *MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃*

![四次挥手](http://upload-images.jianshu.io/upload_images/7109298-fdc60df09aa73706.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* **四次挥手的原因**
> 为什么建立连接是三次握手，而关闭连接却是四次挥手？

建立连接时，服务端在LISTEN状态下收到客户端的syn报文连接请求后，可以把ack和syn（ack起应答作用，syn起同步作用）放在一个报文里来发送。

但是关闭连接时，当收到对方的FIN报文，仅仅表示对方没有数据发送过来了，但是未必所有的数据都发送给对方了；返回ACK给对方，表示已经知道对方没有数据发送了，但是还可能需要发送一些数据给对方后；当发送FIN报文给对方，就表示也没有数据要发送了，同意关闭连接了。所以在这里的ack和FIN报文一般是分开发送的。

* **关于TIME_WAIT状态**

TIME_WAIT表示收到了对方的FIN报文，并且发送出了ACK报文，在等待2MSL时间后就可以回到CLOSED状态。如果在FIN_WAIT_1状态下收到了对方同时带FIN标志和ACK标志的报文，可以直接进入TIME_WAIT状态，不需要经过FIN_WAIT_1状态。

* **为什么TIME_WAIT状态还需要等2MSL后才能进入到CLOSED状态**

> *RFC定义了MSL为2分钟，Linux设置成了30s*

1. 保证主动关闭的一方发送的最后一个ACK报文能够被对方接收，可靠的终止连接

> *假想网络是不可靠的，无法保证最后发送的ACK报文一定会被对方收到，所以对方处于LAST_ACK状态下的socket可能会因为超时未收到ACK报文，而重新发送FIN报文，所以TIME_WAIT状态等待2MSL时间的一个原因就是重发丢失的ACK报文。如果TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到对方重传的FIN报文段，因而也不会再发送一次ACK确认报文，这样对方就无法按照正常的步骤进入CLOSED状态。* 

2. **有足够的时间让这个连接不会跟后面的连接混在一起**

> *有些路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。主动关闭的一方在发送完ACK报文后，在TIME_WAIT状态经过2MSL的时间，就可以使得本连接持续的时间内产生的所有报文都在网络中消失，这样就可以使下一个新的连接中不会出现以前的连接的报文*

> *考虑这样一种情况：关闭某个TCP连接后，又在相同的IP地址和端口上建立了新的连接，这样的话可能会有来自以前连接的报文分组出现在新的连接中，应该避免这种情况发生。而TIME_WAIT状态的持续时间是2倍MSL时间，足够让某个方向上的分组最多存活MSL时间就被丢弃，另一个方向上的应答分组最多存活MSL时间后也被丢弃，通过这样的规则就可以保证以前连接的分组都在网络中被丢弃，避免上面所说的情况发生*

* **TIME_WAIT状态所带来的影响**

当某个连接的一端处于TIME_WAIT状态时，表示这个连接并没有完全断开，这个连接所使用的端口在TIME_WAIT持续的状态内不能再被使用，如果不等待超时重用连接的话，新的连接可能会建立不上。比如说，如果服务端突然挂掉了，那么它在2MSL的时间内是无法重新启动的，因为bind会失败，解决办法是设置socket的SO_REUSEADDR选项，让服务端在2MSL的时间内重新启动。

### 如何实现可靠传输

TCP 协议可以保证数据通信的完整性。由于每一个数据包都带有下一个数据包的编号，接收方如果收到下一个数据包，那么会更新下一轮的ACK编号；如果没有收到下一个数据包，那么 ACK 的编号就不会发生变化，这回导致接收方发送大量重复内容的ACK。如果发送方接收到三个连续的重复ACK，或者超时了还没有收到任何ACK消息，就会确认丢包，从而重新发送这个数据包，如下图：

![TCP重传](http://upload-images.jianshu.io/upload_images/7109298-fe040653ef613db1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* **累计ACK**

TCP不会对每个报文段都发送ACK回复，实际采用的是累计ACK回复，接收方会利用一个ACK回复来通知发送方多个报文段已经成功接收了。通过累计ACK的方式，所需要的ACK回复通常可以降到50%。此外，接收方在应该回复ACK的时候，会故意延迟一些时间，如果在延迟的时间里，有后续的报文段到达，就可以利用累计ACK来一起回复了。

### TCP重传

* **超时重传**

当发送方送出一个TCP报文后，将开始计时，等待该报文的ACK回复。如果接收方正确接收到符合次序的报文，接收方会利用ACK回复发送方。发送方得到ACK回复后，发送接下来的TCP片段。如果直到计时完成，发送方还是没有收到ACK回复，那么发送方推断之前发送的TCP片段丢失，因此重新发送之前的TCP片段。

* **快速重传**

TCP引入了一种叫Fast Retransmit 的算法，**不以时间驱动，而以数据驱动重传**。如果报文没有连续到达，就重传ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。

> *比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6*

### 滑动窗口

TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据，然后发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

TCP滑动窗口分为接收窗口和发送窗口。

* **发送窗口**

对于TCP会话的数据发送方，发送窗口中包括这两部分的数据：已经发送但还没有收到对方ACK回复的报文，未发送但是允许发送的报文。

![发送方滑窗](http://upload-images.jianshu.io/upload_images/7109298-8f61465e6559ee67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当收到接收方对于发送窗口中后续字节的确认时，窗口向右滑动，如下图：

![收到ACK=36后向右滑动](http://upload-images.jianshu.io/upload_images/7109298-7b197bab2e92ddfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* **接收窗口**

对于TCP会话的的数据接收方，接收窗口包含三个部分：

![接收方滑窗](http://upload-images.jianshu.io/upload_images/7109298-f1148635724a21ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Received; ACKed; Not Sent to Proc表示没有被应用程序读取的数据。

接收窗口只有在前面所有的字节都确认的情况下才会移动，当在前面还有字节未接收但是已经收到后面字节的情况下，窗口不会移动，也不对后续字节确认，以此确保发送方会对这些数据重传。

### TCP流量控制

TCP协议会根据情况自动改变滑窗大小，以实现流量控制。流量控制(flow control)是指接收方将自己的接收窗口（advertised window）的大小通知给发送方，从而指导发送方修改发送窗口（offered window）的大小。

发送方在收到window size的通知时，会调整自己滑窗的大小，让offered window和advertised window相符。这样，发送窗口变小，文本流发送速率降低，从而减少了接收方的负担。

* **零窗口**

advertised window大小有可能变为0，这意味着接收方的接收能力降为0。发送方收到大小为0的advertised window通知时，停止发送。当接收方经过处理，再次产生可用的advertised window时，接收方会通过纯粹的ACK回复来通知发送方，让发送方恢复发送。然而，ACK回复的传送并不是可靠的。如果该ACK回复丢失，那么TCP传输将陷入死锁(deadlock)状态。

为此，发送方会在零窗口后，不断探测接收方的窗口。发送方会向接收方发送包含1 byte文本流的TCP片段，并等待ACK回复(该ACK回复包含有window size)。由于有1 byte的数据存在，所以该传输是可靠的，而不用担心ACK回复丢失的问题。如果探测结果显示窗口依然为0，发送方会等待更长的时间，然后再次进行窗口探测，直到TCP传输恢复。

* **白痴窗口综合症**

TCP要求：
1. 接收方宣告的窗口必须达到一定的尺寸，否则等待
2. 除了一些特殊情况，发送方发送的片段必须达到一定的尺寸，否则等待。特殊情况主要是指需要最小化延迟的TCP应用(比如命令行互动)

### TCP拥塞控制

避免过多的数据注入网络，改善网络的阻塞情况。TCP会维护一个拥塞窗口cwnd（congestion window size），以根据网络状况来调整滑窗大小。

* **慢启动算法-Slow Start**

Slow start的特点是初始速率低，但速率不断倍增。每次进入到slow start状态时，cwnd都需要重置为初始值1。每当收到一个ACK，cwnd++，呈线性上升；每当过了一个往返时间RTT，cwnd = cwnd*2，呈指数让升。还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入**拥塞避免**。
如果网速很快的话，ACK也会返回得快，RTT也会短，那么这个慢启动就一点也不慢。

* **拥塞避免算法-Congestion Avoidance**

进入**拥塞避免**后，收到一个ACK时，cwnd = cwnd + 1/cwnd；当每过一个往返时间RTT，cwnd = cwnd + 1。所以在congestion avoidance下，cwnd线性增长，增长速率慢，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。
* **拥塞状态时的算法**

如果在congestion avoidance下有报文丢失，分为两种情况：

1. 超时重传，sshthresh =  cwnd /2，cwnd 重置为 1，进入慢启动过程。
2. 快速重传，sshthresh = cwnd，cwnd = cwnd /2，进入快速恢复算法。

* **快速恢复算法 – Fast Recovery**

快速重传和快速恢复算法一般同时使用。进入Fast Recovery之前，cwnd 和 sshthresh已被更新：sshthresh = cwnd，cwnd = cwnd /2。进入Fast Recovery算法后：
1. cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）
2. 重传3个重复的 ACKs指定的数据包
3. 如果再收到 重复的 Acks，那么cwnd = cwnd +1
4. 如果收到了新的Ack，那么cwnd = sshthresh ，然后就进入了拥塞避免的算法了

* **总结思想**

总的来说，发送速率总是在增长。如果报文丢失，则重置cwnd，并快速增长。增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点(sshthred)会随着网络状况(何时出现报文丢失)更新。通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。

### TCP粘包问题

* **粘包原因**

粘包现象出现的原因是多方面的，可能有发送方造成，也可能由接收方造成。
1. 发送端需要等缓冲区满才发送出去，造成粘包
> *TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据*

2. 接收方没有及时接收缓冲区的包，造成多个包接收
> *若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据*

* **何时该考虑粘包问题**

1. 短连接时，每次发送数据就建立连接，双方发送完就关闭连接，不用考虑。
2. 发送的数据无结构，如文件传输，也不考虑。
3. 如果双方建立连接，需要在连接后一段时间内发送不同结构数据，需要考虑粘包。比如，发送方连续发送两个包含不同结构数据的包出去，接收方一次接收到后就无法处理。

* **解决粘包**

1. 对于发送方引起的粘包现象，可通过编程设置来避免，使用TCP的强制数据立即传送的操作指令push，可以将本段数据立即发送出去，不用等待发送缓冲区满。但是降低了发送效率，影响性能。
2. 对于接收方引起的粘包，应该优化程序设计，使得接收方及时接收数据，但是也只能减少出现粘包的可能性。
3. 由接收方控制，将一包数据按结构字段分多次接收，然后合并，通过这种手段来避免粘包。也是效率比较低。

## 关于UDP
---

### TCP和UDP的区别

1. TCP是面向连接的，udp是无连接的；
2. TCP提供可靠的服务，TCP保证数据的正确性和数据顺序到达；udp没有这种保证；
3. TCP是面向字节流的，把数据看成是没有结构的字节流；udp是面向报文的；
4. TCP要求更多的系统资源，首部的开销是20字节；udp开销比较小，首部只有8个字节；
5. 每一条TCP连接只能是点到点的；udp支持一对一，一对多，多对一和多对多的交互通信。

### TCP、udp相比的优缺点

* TCP

1. TCP优点

可靠、稳定。建立连接时会有三次握手，传输数据时有确认机制、重传机制、流量控制、拥塞控制，还会断开连接来释放系统资源。

2. 缺点

速度慢、效率低，占用更多的系统资源，容易被攻击。

* UDP

1. udp优点

速度快。常用于视频、语音等应用。

2. udp缺点

不可靠、不稳定。
