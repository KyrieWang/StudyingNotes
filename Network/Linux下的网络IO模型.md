### 阻塞、非阻塞
---

* **阻塞和非阻塞**

阻塞/非阻塞是针对某一个事件（线程/进程）来说的。

对于阻塞，如果一个事件在触发一个请求后，由于条件不满足，那么这个事件就会停在这个请求上。比如说，一个线程在发出一个系统调用之后，由于当前不满足执行这个请求的条件，那么这个线程就会停在这个请求上，直到请求执行完毕或者出现异常（错误）返回，这个线程阻塞的时候操作系统不会分配CPU时间。

对于非阻塞，如果一个事件在触发一个请求后，无论当前是否满足执行请求的条件，都会把结果或者异常（错误）返回给请求事件，这个事件不会被阻塞。

### 同步、异步
---

* **同步和异步**

同步/异步是针对多个事件（线程/进程）来说的，以单个的事件来谈同步/异步是没有意义的。

对于同步，相当于一个事件A需要等待另一个事件B的完成才能完成。

对于异步，相当于事件A的完成需要事件B的执行结果，但是在B完成之前A不会因为B没有完成而等待，而是继续执行，等待B完成之后自动补全A的任务。

### I/O模式
---

* **缓存 I/O**

缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

* **I/O过程**

对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：

1. 等待数据准备 (Waiting for the data to be ready)
2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)

### socket I/O模型
---

#### 阻塞 I/O（blocking IO）

> *在linux中，默认情况下所有的socket都是blocking*

在这个模式中，用户空间的应用程序执行一个系统调用并阻塞，直到系统调用完成为止(数据传输完成或发生错误)，即Socket设置为阻塞模式，当socket不能立即完成I/O操作时，进程或线程进入等待状态，直到操作完成。如下图：

![阻塞IO](http://upload-images.jianshu.io/upload_images/7109298-8c57cea5111e8e3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包，这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。

该模式的优点是开发程序简单，等待的过程中占用的系统资源很少，适合立即收发数据而且要处理的套接字比较少的情况。

缺点在于进程（线程）将被阻塞，在此期间无法执行其他计算或响应其他的网络请求，对于需要处理大量连接的情况是无法接受的。但是也有解决办法——多线程，让每个连接都拥有独立的线程，这样任何一个连接的阻塞都不会影响到其他连接。并且应该使用线程池来减少创建和销毁线程带来的开销，重用已有的线程，能够在一定程度上减轻系统资源的压力。

#### 非阻塞 I/O（nonblocking IO）

> *nonblocking IO的特点是用户进程需要不断的主动询问kernel数据是否准备好了*

在这种模型中，系统调用是以非阻塞的形式打开的。当所请求的IO操作无法立即完成时，不会让线程睡眠，而是让调用立即返回一个错误代码。所以需要多次调用IO函数来测试数据是否已经准备好，这样会占用大量cpu时间，效率不高。如下图：

![非阻塞IO](http://upload-images.jianshu.io/upload_images/7109298-c4b2b7a4389c12ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。

实际应用中，这种I/O模型的直接使用并不常见，编程复杂，需要不停的查询，浪费系统资源。

#### I/O多路复用（ IO multiplexing）

> *I/O multiplexing就是常说的select，poll，epoll，也称这种IO方式为event driven IO。多路复用的好处就在于单个进程就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这三个调用会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程*

在这种模型中，对于每一个socket，一般都设置成为non-blocking，但是整个用户进程其实是一直被block的，只不过进程是被select/poll/epoll调用给block了，而不是被socket IO给block。如下图

![IO多路复用](http://upload-images.jianshu.io/upload_images/7109298-56389a67a20dd16e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当用户进程调用了select，那么整个进程会被block，同时kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。

I/O 多路复用的特点是通过一种机制让一个进程能同时等待多个套接字描述符，而这些套接字描述符其中的任意一个进入就绪状态，select、epoll等调用就可以返回。

多路复用的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。所以，如果处理的连接数不是很多的话，使用select/epoll不一定比使用multi-threading + blocking IO的性能更好。



#### 信号驱动I/O（ signal driven IO）

开启套接字的信号驱动I/O功能，并通过系统调用按照一个信号处理函数，该系统调用立即返回，进程不被阻塞继续工作；当数据准备好时内核就为这个进程产生一个SIGIO信号，可以在信号处理函数里处理数据。如下图：

![信号驱动I/O](http://upload-images.jianshu.io/upload_images/7109298-ae9b10c004aab514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

该模型的优势在于等待数据到达期间，进程不会被阻塞，主循环可以继续进行。

#### 异步IO（asynchronous IO）

Linux下用的比较少。异步I/O模型是由内核通知应用进程I/O操作什么时候完成， 当一个异步过程调用发出后，调用者不能立刻得到结果，进程不会阻塞，可以执行其他的操作。有数据到达时，就会产生一个信号或者执行一个基于线程的回调函数来完成本次I/O操作。如下图：

![异步I/O](http://upload-images.jianshu.io/upload_images/7109298-3a10b66068d46402.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

比如说，从内核的角度来看，当它收到一个异步的read操作，首先会立刻返回，所以不会阻塞用户进程；内核会等待数据准备好，然后将数据拷贝到用户空间，然后给用户进程发送一个信号，告诉它read操作完成了。

#### 几种模型的总结、对比

* **blocking和non-blocking的区别**

调用blocking I/O会一直阻塞住对应的进程直到操作完成，而non-blocking I/O在内核还在准备数据的情况下会立刻返回。

在non-blocking I/O中，虽然进程大部分时间都不会被阻塞，但是它仍然要求进程去主动的区检测数据是否准备好，并且当数据准备完成以后，也需要进程主动的再次调用I/O操作来处理数据（拷贝到用户空间）。

* **synchronous IO和asynchronous IO的区别**

synchronous IO做”IO operation”的时候会将进程阻塞，”IO operation”是指真实的IO操作，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。比如说，non-blocking IO在执行recvfrom这个系统调用的时候，如果内核的数据没有准备好，这时候不会阻塞进程；但是，当内核中数据准备好的时候，recvfrom会将数据从内核拷贝到用户空间中，在拷贝数据这段时间内，进程可以说是被阻塞的。

而asynchronous I/O则不一样，当进程发起I/O 操作之后，就直接返回了，直到k内核发送一个信号，告诉进程IO操作完成。在这整个过程中，进程完全没有被阻塞。
